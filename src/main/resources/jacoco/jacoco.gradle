apply plugin: 'com.github.kt3k.coveralls'

allprojects {
	apply plugin: 'java'
	apply plugin: 'jacoco'
}
/**
 * Default metrics.
 */
ext {
	minCoverageRates = [
		'instruction': 95,
		'branch'     : 95,
		'line'       : 95,
		'complexity' : 95,
		'method'     : 95,
		'class'      : 95
	]
}

/**
 * Verifies that a single java project has the desired consolidated coverage.
 */
jacocoTestReport() {
	reports {
		xml.enabled true
	}
	doLast {
		coverageVerification("${jacoco.reportsDir}/test/jacocoTestReport.xml")
	}
}

/**
 * Verifies that a multi java project has the desired coverage. 
 */
task jacocoMultiprojectReport(type: org.gradle.testing.jacoco.tasks.JacocoReport) {
    dependsOn = subprojects.test
    additionalSourceDirs = files(subprojects.sourceSets.main.allSource.srcDirs)
    sourceDirectories = files(subprojects.sourceSets.main.allSource.srcDirs)
    classDirectories =  files(subprojects.sourceSets.main.output)
    executionData = files(subprojects.jacocoTestReport.executionData)
    reports {
        html.enabled = true
        xml.enabled = true
    }
    
    onlyIf = {
        true
    }
    
    doFirst {
        executionData = files(executionData.findAll { it.exists() })
    }

    doLast {
		coverageVerification("${buildDir}/reports/jacoco/jacocoMultiprojectReport/jacocoMultiprojectReport.xml")
	}
}

/**
 * Compares each metric against the specified goals for the given report.
 */
def coverageVerification(jacocoReportPath) {
	def report = file(jacocoReportPath)
	logger.lifecycle("Checking coverage results: ${report}")

	def parser = new XmlParser()
	parser.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);
	parser.setFeature("http://apache.org/xml/features/disallow-doctype-decl", false)
	def results = parser.parse(report)

	def percentage = {
		def covered = it.'@covered' as Double
		def missed = it.'@missed' as Double
		((covered / (covered + missed)) * 100).round(2)
	}

	def counters = results.counter
	def metrics = [:]
	metrics << [
		'instruction': percentage(counters.find { it.'@type'.equals('INSTRUCTION') }),
		'branch'     : percentage(counters.find { it.'@type'.equals('BRANCH') }),
		'line'       : percentage(counters.find { it.'@type'.equals('LINE') }),
		'complexity' : percentage(counters.find { it.'@type'.equals('COMPLEXITY') }),
		'method'     : percentage(counters.find { it.'@type'.equals('METHOD') }),
		'class'      : percentage(counters.find { it.'@type'.equals('CLASS') })
	]


	def failures = []
	def successes = []
	metrics.each {
		def limit = minCoverageRates[it.key]
		def coverageRate = "- ${it.key} coverage rate is: ${it.value}%, minimum is ${limit}%"
		if (it.value < limit) {
			failures.add(coverageRate)
		} else {
			successes.add(coverageRate)
		}
	}

	if (failures) {
		logger.quiet("------------------ Code Coverage Failed -----------------------")
		failures.each {
			logger.quiet(it)
		}
		logger.quiet("---------------------------------------------------------------")
		throw new GradleException("Code coverage failed")
	} else {
		logger.quiet("Passed Code Coverage Checks")
	}
}
